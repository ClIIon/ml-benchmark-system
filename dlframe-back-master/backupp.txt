<template>
  <el-container class="app-container">
    <!-- é¡¶éƒ¨æ ‡é¢˜ -->
    <el-header>
      <h1>æœºå™¨å­¦ä¹ ç»å…¸åå¤§ç®—æ³• Benchmark å¯è§†åŒ–å¹³å°</h1>
    </el-header>

    <el-main>
      <!-- æ•°æ®é›†é€‰æ‹© -->
      <el-card class="card">
        <h3>é€‰æ‹©æ•°æ®é›†</h3>
        <el-select v-model="selectedDataset" placeholder="è¯·é€‰æ‹©æ•°æ®é›†" @change="onDatasetChange">
          <el-option v-for="d in datasets" :key="d.value" :label="d.label" :value="d.value" />
        </el-select>
      </el-card>

      <!-- ç®—æ³•é€‰æ‹© + å¯åŠ¨æŒ‰é’® -->
      <el-card class="card" v-if="selectedDataset">
        <h3>é€‰æ‹©ç®—æ³•</h3>
        <el-select
          v-model="selectedModel"
          placeholder="è¯·é€‰æ‹©ç®—æ³•"
          :key="selectedDataset"
          style="width: 300px"
        >
          <el-option v-for="m in modelsForDataset" :key="m.value" :label="m.label" :value="m.value" />
        </el-select>

        <div style="margin-top: 20px; text-align: center;">
          <el-button type="primary" @click="runBenchmark">
            ğŸš€ è¿è¡Œ Benchmark
          </el-button>
        </div>
      </el-card>

      <!-- è¿›åº¦æç¤º -->
      <el-card class="card" v-if="progressMsg">
        <h3>è¿è¡Œè¿›åº¦</h3>
        <p>{{ progressMsg }}</p>
	<el-progress :percentage="progressPercent" :status="progressPercent < 100 ? '' : 'success'" />
          striped
          striped-flow
      </el-card>

      <!-- æŒ‡æ ‡ç»“æœå±•ç¤º -->
      <el-card class="card" v-if="lastMetrics">
        <h3>å½“å‰ç®—æ³•è¯„ä¼°æŒ‡æ ‡</h3>
        <el-table :data="metricsTable" border>
          <el-table-column prop="metric" label="æŒ‡æ ‡" />
          <el-table-column prop="value" label="æ•°å€¼" />
        </el-table>
      </el-card>

      <!-- æŸ±çŠ¶å›¾ -->
      <el-card class="card" v-if="true">
        <h3>è¯„ä¼°æŒ‡æ ‡å¯¹æ¯”æŸ±çŠ¶å›¾</h3>
        <div ref="barChart" style="width:800px; height:400px; background:#eee;"></div>
      </el-card>
    </el-main>
  </el-container>
</template>

<script setup>
import { ref, nextTick, onMounted } from "vue";
import * as echarts from "echarts";
import { io } from "socket.io-client";   // âœ… WebSocket

const datasets = [
  { label: "ä¹³è…ºç™Œ", value: "breast_cancer" },
  { label: "è‘¡è„é…’", value: "wine" },
  { label: "æ³¢å£«é¡¿æˆ¿ä»·", value: "boston" },
  { label: "Fashion-MNIST", value: "fashion_mnist" },
];

const datasetModels = {
  breast_cancer: [
    { label: "é€»è¾‘å›å½’", value: "logistic_regression" },
    { label: "å†³ç­–æ ‘", value: "decision_tree" },
    { label: "éšæœºæ£®æ—", value: "random_forest" },
    { label: "SVM", value: "svm" },
    { label: "KNN", value: "knn" },
    { label: "æœ´ç´ è´å¶æ–¯", value: "naive_bayes" },
    { label: "GBDT", value: "gbdt" },
  ],
  wine: [
    { label: "é€»è¾‘å›å½’", value: "logistic_regression" },
    { label: "å†³ç­–æ ‘", value: "decision_tree" },
    { label: "éšæœºæ£®æ—", value: "random_forest" },
    { label: "SVM", value: "svm" },
    { label: "KNN", value: "knn" },
    { label: "æœ´ç´ è´å¶æ–¯", value: "naive_bayes" },
  ],
  boston: [
    { label: "çº¿æ€§å›å½’", value: "linear_regression" },
    { label: "å†³ç­–æ ‘", value: "decision_tree" },
    { label: "éšæœºæ£®æ—", value: "random_forest" },
    { label: "GBDT", value: "gbdt" },
  ],
  fashion_mnist: [
    { label: "é€»è¾‘å›å½’", value: "logistic_regression" },
    { label: "SVM", value: "svm" },
    { label: "KNN", value: "knn" },
    { label: "K-means", value: "kmeans" },
    { label: "PCA", value: "pca" },
  ],
};

const selectedDataset = ref("");
const selectedModel = ref("");
const modelsForDataset = ref([]);

const allResults = ref([]); // å­˜å‚¨æ‰€æœ‰è¿è¡Œç»“æœ
const lastMetrics = ref(null);
const metricsTable = ref([]);
const progressMsg = ref("");

const barChart = ref(null);
let chartInstance = null;

// âœ… å»ºç«‹ WebSocket è¿æ¥
const socket = io("http://127.0.0.1:5000");

onMounted(() => {
  if (barChart.value) {
    chartInstance = echarts.init(barChart.value);
    window.addEventListener("resize", () => chartInstance.resize());
  }

  // ç›‘å¬è¿›åº¦
  socket.on("progress", (msg) => {
    progressMsg.value = msg.status;
  });

  // ç›‘å¬ç»“æœ
  socket.on("result", async (res) => {
    lastMetrics.value = res.metrics;
    metricsTable.value = Object.entries(lastMetrics.value).map(([k, v]) => ({
      metric: k,
      value: typeof v === "number" ? v.toFixed(4) : v,
    }));

    const idx = allResults.value.findIndex(r => r.model === res.model);
    if (idx !== -1) {
      allResults.value[idx].metrics = lastMetrics.value;
    } else {
      allResults.value.push({ model: res.model, metrics: lastMetrics.value });
    }

    console.log("allResults:", allResults.value);

    await nextTick();
    updateBarChart(allResults.value);
  });

  socket.on("error", (err) => {
    alert(err.error);
  });
});

function onDatasetChange() {
  selectedModel.value = "";
  modelsForDataset.value = datasetModels[selectedDataset.value] || [];
  allResults.value = [];
  lastMetrics.value = null;
  metricsTable.value = [];
  progressMsg.value = "";
  if (chartInstance) chartInstance.clear();
}

function runBenchmark() {
  if (!selectedDataset.value || !selectedModel.value) {
    alert("è¯·å…ˆé€‰æ‹©æ•°æ®é›†å’Œç®—æ³•ï¼");
    return;
  }

  progressMsg.value = "ä»»åŠ¡å·²æäº¤...";
  socket.emit("run_benchmark", {
    dataset: selectedDataset.value,
    model: selectedModel.value,
  });
}

function updateBarChart(results) {
  if (!chartInstance) {
    console.warn("ECharts æœªåˆå§‹åŒ–");
    return;
  }
  console.log("æ›´æ–°å›¾è¡¨æ•°æ®:", results);

  const metricsSet = new Set();
  results.forEach(r => {
    Object.keys(r.metrics).forEach(k => {
      if (typeof r.metrics[k] === "number") {
        metricsSet.add(k);
      }
    });
  });
  const metricKeys = Array.from(metricsSet);

  const series = results.map((r, idx) => ({
    name: r.model,
    type: "bar",
    data: metricKeys.map(k => (typeof r.metrics[k] === "number" ? r.metrics[k] : 0)),
  }));

  const option = {
    tooltip: { trigger: "axis" },
    legend: { data: results.map(r => r.model) },
    xAxis: { type: "category", data: metricKeys },
    yAxis: {
      type: "value",
      min: val => val.min - 0.05,
      max: val => val.max + 0.05,
      scale: true,
    },
    series,
  };

  console.log("ECharts option:", option);
  chartInstance.setOption(option);
}
</script>

<style>
.app-container {
  margin: 20px;
}
.card {
  margin: 20px 0;
  padding: 15px;
}
</style>
